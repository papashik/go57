# Тип функции. Функции высшего порядка
Материалы про [типы функций](https://metanit.com/go/tutorial/2.15.php) и [анонимные функции](https://metanit.com/go/tutorial/2.16.php) на стороннем ресурсе.
## Вспоминаем
Вспомним, что такое функция.<br>
**Функция**, или **подпрограмма** — фрагмент программного кода, к которому можно обратиться из другого места программы.<br>
Что эквивалентно какой-то последовательности машинных инструкций, загруженной в оперативную память.

Если мы попытаемся просто послать имя функции на вывод, то выведется просто адрес первой инструкции этой последовательности (так называемый **адрес функции**):
```golang
package main
import "fmt"

func test() int {
    return 57
}

func main() {
    fmt.Println(test())		// выведет `57` - обычный вызов функции со скобочками после имени
    fmt.Println(test)		// выведет что-то по типу `0x100e4ab90` - адрес этой функции в оперативной памяти
    fmt.Println(main)		// выведет что-то по типу `0x104162b90` - и у функции main() есть адрес
}
```
Кроме адреса у функции есть еще **сигнатура** (например, `func hello(a, b int) (string, int)`) - та часть функции, с помощью которой компилятор идентифицирует ее среди других - а именно, это формальные параметры и возвращаемые значения функции (если компилятор не будет знать, какие параметры принимает функция, он не сможет сказать, корректно ли она была вызвана в программе).

## Тип функции. Функции в переменных
Адрес функции имеет определенный тип значения - так называемый **тип функции**. Значениями определенного типа выступают адреса функций с одинаковыми сигнатурами. Например, функции с сигнатурами `func a(one int) int` и `func b(one int) int` имеют один и тот же тип, а функция `func c(one, two int) int` имеет другой тип (она не сможет быть вызвана в том же месте, где могут быть вызваны две прошлые функции).

Запись типа функции практически идентична записи сигнатуры:
```golang
package main
import "fmt"

func one() {}                        // её адрес имеет тип `func()`

func two(s string) {}                // её адрес имеет тип `func(string)`

func three() int { return 57 }       // её адрес имеет тип `func() int`

func four (a, b int) (int, int) {    // её адрес имеет тип `func(int, int) (int, int)`
    return a, b
}

func main() {
    // тип переменной совпадает с типом функции one() - теперь в переменной one_var лежит адрес функции one()
    var one_var func() = one         
    fmt.Println(one, one_var)        // выведет одинаковые адреса

    // теперь функцию three() можно вызвать с помощью переменной three_var!
    var three_var func() int = three
    fmt.Println(three_var())         // выведет `57`
}
```
С помощью типа функции нужен можно работать с функциями как с переменными: принимать их в качестве аргументов, использовать как возвращаемые параметры и использовать функциональные литералы.

## Функциональные литералы (анонимные функции)
С литералами вы уже сталкивались - это просто конкретное значение, используещееся в коде программы. Например, числовой литерал: `5`, строковой литерал: `"привет"`, массивовый литерал: `[]int{1, 2, 3, 4, 5}`, структурный литерал: `My_struct{1, 2}` и т.д.

**Функциональный литерал**, или **анонимная функция** (ещё: лямбда-функция) - это функция, которая объявляется в месте использования и не получает уникального идентификатора (имени) для доступа к ней (до этого мы объявляли только глобальные функции, доступные из любого места программы).<br>
Функциональный литерал создаётся так:
```
// Имена параметров нужны для использования внутри тела
<тип_функции_с_именами_параметров>{ <тело_функции> }        // очень похоже на структурный литерал: <тип_структуры>{ <перечисление_значений_полей_структуры> }	
```
Отличается он от обычного объявления функции **только тем, что не имеет имени функции!** - это единственное, что нужно знать для создания литералов.

Функциональный литерал можно воспринимать как объект функции, заданный внутри другой функции. Его можно использовать при создании, можно положить в переменную или передать в другую функцию - по факту, это обычное значение переменной (которая имеет тип функции).

### Пример
```golang
// содержимое функции main()

// теперь в переменной first лежит доступная для вызова функция
var first func() = func() { fmt.Println("First") }          
first()                     // выведет `First`

// лямбда-функция, возвращающая умноженное на 2 переданное число
var second func(int) int = func(a int) int { return a * 2}  
fmt.Println(second(57))	    // выведет `114`

// забавный пример, поймите сами, как он работает
fmt.Println(func(arr []int) int {                           
    if len(arr) == 0 {
        return 0
    }
    m := arr[0]
    for i := range arr {
        if arr[i] > m {
            m = arr[i]
        }
    }
    return m
}([]int{7, 2, 1, 9, 4}))     // выведет `9`	
```
Анонимные функции имеют доступ к окружению - локальным переменным той функции, в которой они объявлены. Это позволяет использовать их для создания генераторов, счетчиков с помощью переменных внешней функции - об этом позже.

## Функции высшего порядка. Использование функций в качестве параметров других функций
Функции, тем или иным способом использующие другие функции (например, принимающие в качестве параметров или возвращающие в качестве значений), называются **функциями высшего порядка**.

### Примеры
```golang
package main
import "fmt"

// функция высшего порядка twice() дважды применяет переданную функцию к числу и возвращает результат
func twice(a int, f func(int) int) int {
    return f(f(a))
}

// функция высшего порядка mul() создаёт и возвращает функцию, умножающую свой аргумент на заранее заданное число
func mul(a int) func(int)int {
    return func(num int) int { return a * num }
}

func main() {
    // к числу 3 два раза применяем функцию возведения числа в квадрат (передаётся функциональным литералом)
    fmt.Println(twice(3, func(a int) int { return a * a })) // выведет `81`

    // с помощью mul() создаём функцию, умножающую переданный аргумент на 7, и кладем её в переменную f
    f := mul(7)	        
    fmt.Println(f(5))   // выведет `35` - 7 * 5
}
```

## Дополнительно. Замыкания. Генераторы
**Замыкание** (англ. _closure_) в программировании — функция первого класса (созданная с целью передачи другим функциям), в теле которой присутствуют ссылки на переменные, объявленные вне тела этой функции в окружающем коде и не являющиеся её параметрами. Говоря другим языком, замыкание — функция, которая ссылается на свободные переменные в своей области видимости.

С помощью замыкания можно создавать так называемые генераторы. <br>
**Генератор** — это подпрограмма, которая может возвращать очередное значение и автоматически сохранять и возобновлять своё состояние для возврата следующего значения.
Генератор похож на функцию, возвращающую массив, поскольку он имеет параметры, может быть вызван и возвращает последовательность значений. Однако выполнение генератора не является непрерывным. Вместо того, чтобы создавать массив, содержащий все значения, и возвращать их в виде единой сущности, генератор возвращает значения по одному, что требует меньше памяти и позволяет вызывающему объекту немедленно приступить к обработке первых нескольких значений.

### Пример
Создание простого генератора-счётчика, возвращающего каждый раз следующее число:
```golang
package main
import "fmt"

// функция для создания генератора
func make_gen() func() int {
    var counter int            // переменная-счётчик

    return func() int {        // возвращает функцию (генератор), которая
        counter++              // при каждом своём вызове увеличивает значение счётчика
        return counter         // и возвращает его
    }
}

func main() {
    my_gen := make_gen()        // создаём генератор и кладём его в переменную my_gen
    fmt.Println(my_gen())       // выведет `1`
    fmt.Println(my_gen())       // выведет `2`
    fmt.Println(my_gen())       // выведет `3`
}
```
Работает это таким образом, что при вызове `make_gen()` один раз инициализируется (выделяется в памяти) переменная `counter` и возвращается функция, каким-то образом использующая этот счётчик. Сборщик мусора (который удаляет из памяти неиспользуемые переменные), не может удалить из памяти переменную `counter`, так как она все еще используется в возвращённой функции-генераторе. И пока она висит в памяти, генератор может работать с ней как ему угодно (для него она выступает в роли глобальной переменной, хоть таковой и не является).


