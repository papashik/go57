# Golang - основы 3. Функции
**Функция**, или **подпрограмма** — фрагмент программного кода, к которому можно обратиться из другого места программы.
Функция в программировании похожа на функцию в математике - она принимает какие-то аргументы и возвращает какие-то значения.
В общем случае как принимаемых аргументов, так и возвращаемых значений может не быть.

Объявление глобальной функции записывается так:
```golang
func <имя> (<формальные параметры>) <возвращаемые значения>  {
    <тело функции>
}
```
<имя> - это название функции, с помощью него можно получить к ней доступ;<br>
<формальные параметры> - список аргументов функции (и их типов);<br>
<возвращаемые значения> - список возвращаемых значений функции (и их типов);<br>
<тело функции> - программа, которая будет выполняться при вызове функции.

**Сигнатура функции** - это та часть функции, с помощью которой компилятор
идентифицирует ее среди других - а именно, это _формальные параметры и возвращаемые значения функции_.

Параметры записываются в виде `(пар1 тип1, ..., парM типM)`.
При этом, если у идущих подряд параметров совпадает тип, тип можно указать только один раз после них.

Возвращаемые значения в общем случае записываются так же, как параметры, а 
в случае единственного возвращаемого значения допустимо просто указать его тип.

### Пример: `MyFunc` - функция с пустой сигнатурой, печатающая `Hello!`:
```golang
package main

import "fmt"

func MyFunc() {
    fmt.Println("Hello!")
}

func main() {
    MyFunc() // вызов функции, напечатается `Hello!`
    MyFunc() // и еще раз напечатается `Hello!`
}
```
### Пример: `MyPrintFunc` - функция, принимающая строку и выводящая её в консоль:
```golang
package main

import "fmt"

func MyPrintFunc(parameter string) {
    fmt.Println(parameter)
}

func main() {
    a := "Pavel"
    MyPrintFunc(a) // вызов функции, напечатается `Pavel`
}
```
При вызове функции вместо **формальных параметров** (в данном случае `parameter`) 
подставляются **фактические параметры** - аргументы, передаваемые в функцию при ее вызове (в данном случае переменная `a`).

## Возврат значений
Оператор `return` (с англ. вернуть) прекращает исполнение функции и возвращает выполнение программы в точку вызова.
При этом на то место, откуда была вызвана функция, подставляются возвращаемые значения
(она возвращает их туда, откуда их попросили - на то они и возвращаемые).

Общая форма записи выглядит так: `return <возвращаемые значения>`
```golang
package main

import "fmt"

func MySummingFunc(a, b int) int {
    return a + b // возвращает сумму переданных ей аргументов
}

func main() {
    a, b := 3, 5
    fmt.Println(MySummingFunc(a, b)) // выведет `8`
}
```

### Пример - возврат нескольких значений
```golang
package main

import "fmt"

func MyCalculatingFunc(a, b int) (int, int) {
    return a + b, a * b // возвращает сумму и произведение переданных ей аргументов
}

func main() {
    a, b := 3, 5
    sum, mul := MyCalculatingFunc(a, b)
    fmt.Printf("sum = %d, mul = %d", sum, mul) // выведет `sum = 8, mul = 15`
}
```

### Пример - `return` без возврата значений
```golang
package main

import "fmt"

func MyCheckingFunc(x int, arr []int) {
    // функция проверяет, есть ли X в срезе
    for _, v := range arr {
        if v == x {
            fmt.Println(x, "найдено!")
            return // дальше искать необязательно, производим возврат
        }
    }
    fmt.Println(x, "не найдено :(") // выполнится только если Х в срезе нет
}

func main() {
    arr := []int{1, 2, 3, 4}

    MyCheckingFunc(2, arr) // выведет `2 найдено!`
    MyCheckingFunc(5, arr) // выведет `5 не найдено :(`
}
```

## Области видимости
Рассмотрим такой пример:
```golang
package main

import "fmt"

func MyTestFunc(x, y int) {
    a := x + y
    fmt.Println("Сумма равна", a)
}

func main() {
    x, y := 1, 2
    a := x * y
    b := x + y
    MyTestFunc(a, b) // выведет `Сумма равна 5`
}
```

Как мы видим, имена некоторых переменных (а также формальных и фактических параметров) совпадают в телах функций `main` и `MyTestFunc`.
Тем не менее, компилятор не выдает ошибку о повторном объявлении 
(если бы мы повторно объявили переменную в теле одной и той же функции, ошибка бы была).
Дело в том, что переменные внутри каждой функции "видит" только эта функция и функции, объявленные внутри неё.<br>
Переменные, объявленные внутри тела функции (или же являющиеся формальными параметрами) называются **локальными**.<br>
Переменные, объявленные вне тел функций называются **глобальными**.

Поэтому, если в одной глобальной функции есть локальная переменная `x`, и в другой глобальной функции есть локальная переменная `x`, то никак конфликтовать они между собой не будут.

Если рассмотреть чуть более общий случай, то в Go **область видимости** - совокупность мест в программе, откуда доступно значение той или иной переменной - открывается и закрывается фигурными скобками `{}`. Например:
```golang
package main

import "fmt"

var b int = 2 // b объявлена в глобальной области видимости - к ней можно обратиться отовсюду

func MyTestFunc(x, y int) int {
    // вместе с открытой фигурной скобкой открывается новая область видимости
    // переменные, объявленные, в этой функции, не будут видны после ее завершения
    test := x + y // к переменной test не получится обратиться извне функции 
    test += b
    return test
}

func main() {
    // здесь видна только переменная b
    b = 4 // можем ее поменять
    r := 3
    // здесь видны переменные b и r

    if r == 3 {
        a := 1
        // здесь видны переменные b, r, a
        fmt.Println(a)
    }
    // здесь переменная a уже не видна - она вышла из области видимости, видны b и r

    fmt.Println(MyTestFunc(b, r)) // выведет `11`
}
```
## Еще немного интересного
### Булевы значения
Этот тип данных не был упомянут в первом уроке, а зря.
Он называется `bool` (возможно, вы пользовались им в Python) и способен принимать всего два значения: `true` и `false` (да и нет).
При использовании в качестве какого-нибудь флажка (нашли/не нашли элемент, содержится в массиве/не содержится и т.д.) он предпочтительней любого другого типа, так как занимает в памяти всего один бит (к примеру, тип `int` занимает 32 или 64 бита).
Тип `bool` является результатом операций сравнения (`==`, `<`, `>` и т.д.), а также логических операций (`&&` - логическое И, `||` - логическое ИЛИ, `!` - логическое НЕ).
### Немного про указатели
Важный факт про срезы: при передаче в функцию параметра тип срез(`[]int`), передается тот же самый срез, который существует в вызывающей функции (если говорить строго, то в переменной типа срез лежит не массив, а указатель на массив (его адрес в памяти), и его можно менять с помощью этого указателя). Пример:
```golang
package main

import "fmt"

func Change(arr []int) {
    for i := range arr {
        arr[i] *= 2 // умножает каждый элемент среза на 2
    }
}

func main() {
    my_array := []int{1, 2, 3, 4, 5}
    Change(my_array)
    fmt.Println(my_array) // выведет `[2 4 6 8 10]`
}
```

При этом, стоит помнить, что с обычными переменными такой трюк не прокатит!
```golang
package main

import "fmt"

func Change(a int) {
    a = 179 // по идее, должно менять переданное число на 179, но такого не происходит
}

func main() {
    my_int := 57
    Change(my_int)
    fmt.Println(my_int) // выведет `57`
}
```
Так как при передаче в функцию обычной переменной (`int`, `float64`, `bool`, фиксированный массив и т.д.) они просто копируются в параметры внутри функции, а через копию изменить оригинал, очевидно, не получится.

## Примеры функций
### Функция, возвращающая четность числа
```golang
func IsEven(a int) bool {
    return a % 2 == 0 // возвращает булево значение (true/false)
}
```
### Функция, проверяющая, есть ли данный элемент в массиве
```golang
func IsPresent(x int, arr []int) bool {
    for i := range arr {
        if arr[i] == x {
            return true // если мы встретили X, возвращаем "правду"
        }
    }
    return false // если мы прошлись по массиву и не встретили X, возвращаем "ложь"
}
```
### Функция, считающая количество вхождений данного элемента в массиве
```golang
func Count(x int, arr []int) int {
    counter := 0
    for i := range arr {
        if arr[i] == x {
            counter++
        }
    }
    return counter // возвращаем итоговое значение счетчика
}
```
