# Golang - основы. Структуры (ДЗ №5)
В этом ДЗ мы познакомимся с самыми известными абстрактными структурами данных - стеком и очередью.

**Стек** /тэ/ (англ. _stack_ — стопка) — абстрактный тип данных, представляющий собой список элементов, организованных по принципу _LIFO_ (англ. last in — first out, «последним пришёл — первым вышел»).<br>
Добавление элемента (принято обозначать словом _Push_ — "затолкать") возможно лишь в начало стека, выборка — тоже только из начала стека (операцию принято обозначать словом _Pop_ — выскочить, хлопнуть), при этом выбранный элемент из стека удаляется.<br>
Принцип работы стека часто сравнивают с магазином в огнестрельном оружии (стрельба начнётся с патрона, заряженного последним) или стопкой тарелок (положить или взять тарелку можно только с вершины стопки).
([Википедия](https://ru.wikipedia.org/wiki/Стек))

**О́чередь** (на англ. _queue_) — абстрактный тип данных, представляющий собой список элементов, организованных по принципу _FIFO_ (англ. first in — first out, «первым пришёл — первым вышел»). <br>
Добавление элемента (принято обозначать словом _Enqueue_ — поставить в очередь) возможно лишь в конец очереди, выборка — только из начала очереди (что принято называть словом _Dequeue_ — убрать из очереди), при этом выбранный элемент из очереди удаляется.<br>
Очередь является интуитивной структурой данных - она встречается в жизни чаще стека, например, очередь в магазин - это тоже _очередь_.
([Википедия](https://ru.wikipedia.org/wiki/Очередь_(программирование)))

## Стек
Создайте:
1. тип структуры `Stack`, имеющий три поля: `top, capacity int` и `data []int`. `top` - это своеобразный "указатель" на вершину стека, он равен количеству элементов в стеке. `capacity` - (с англ.) вместимость стека (размер массива данных). `data` - массив данных (в нашем случае целых чисел);
2. метод `StackInit(n int) Stack` - создает, инициализирует и возвращает созданный стек;
3. метод `(s *Stack) IsEmpty() bool` - проверяет, является ли стек пустым;
4. метод `(s *Stack) Push(element int)` - добавляет элемент в стек. Если стек заполнен, должен вывести в консоль ошибку `"Stack overflow!"` (с англ. _переполнение стека!_);
5. метод `(s *Stack) Pop() int` - удаляет элемент из стека и возвращает его. Если стек пуст, должен вывести в консоль ошибку `"Stack is empty!"` (с англ. _стек пуст!_) и вернуть число `-1`;
6. (_*один из пунктов на пятерку_) метод `(s *Stack) PushSafe(element int)` - "безопасное" добавление элемента в стек. Если стек заполнен, должен увеличить вместимость стека в два раза с сохранением всех элементов и добавить данный элемент.

Пример использования стека:
```golang
// Содержимое функции main()
s := StackInit(100)         // создаем стек размера 100
fmt.Println(s.IsEmpty())    // должен вывести `true` - стек пуст

for i := 0; i <= 10; i++ {
    s.Push(i * i)           // "пушим" в стек несколько элементов
}
fmt.Println(s.IsEmpty())    // должен вывести `false` - стек не пуст

for !s.IsEmpty() {
    fmt.Println(s.Pop())    // пока стек не пуст, "выдергиваем" из него элементы
}                           // должно вывести числа `100`, `81`, ..., `1`, `0`

fmt.Println(s.IsEmpty())    // должен вывести `true` - стек пуст
```

## Очередь
Нюансы реализации можно смотреть в [Википедии](https://ru.wikipedia.org/wiki/Очередь_(программирование)) в разделе "Способы реализации" (в подразделе "Массив").

Создайте:
1. тип структуры `Queue`, имеющий три поля: `start, end int` и `data []int`. `start` - это своеобразный "указатель" на голову очереди, `end` — на элемент, который заполнится, когда в очередь войдёт новый элемент. `data` - массив данных (в нашем случае целых чисел);
2. метод `QueueInit(n int) Queue` - создает, инициализирует и возвращает созданную очередь;
3. метод `(q *Queue) IsEmpty() bool` - проверяет, является ли очередь пустой;
4. метод `(q *Queue) Enqueue(element int)` - добавляет элемент в очередь. Если очередь заполнена, должен вывести в консоль ошибку `"Queue overflow!"`;
5. метод `(q *Queue) Dequeue() int` - удаляет элемент из очереди и возвращает его. Если очередь пуста, должен вывести в консоль ошибку `"Queue is empty!"` и вернуть число `-1`.
6. (_*другой из пунктов на пятерку_) метод `(q *Queue) EnqueueSafe(element int)` - "безопасное" добавление элемента в очередь. Если очередь заполнена, должен увеличить вместимость очереди в два раза с сохранением всех элементов и добавить данный элемент.

Пример использования очереди:
```golang
// Содержимое функции main()
q := QueueInit(100)             // создаем очередь размера 100
fmt.Println(q.IsEmpty())        // должен вывести `true` - очередь пуста

for i := 0; i <= 10; i++ {
    q.Enqueue(i * i)            // добавляем в очередь несколько элементов
}
fmt.Println(q.IsEmpty())        // должен вывести `false` - очередь не пуста

for !q.IsEmpty() {
    fmt.Println(q.Dequeue())    // пока очередь не пуста, "выдергиваем" из неё элементы
}                               // должно вывести числа `0`, `1`, ..., `81`, `100`

fmt.Println(q.IsEmpty())        // должен вывести `true` - очередь пуста
```
