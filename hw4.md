# Golang - основы. Рекурсия, указатели (ДЗ №4)
В этом ДЗ все задачи оцениваются в 1 балл, если не указано иное.

Для выполнения ДЗ может понадобится оператор среза `[start:stop]` (применяется к массивам любого типа),
который возвращает срез, содержащий элементы исходного массива с индексами в полуинтервале `[start, stop)`.<br>
`start` и/или `stop` могут быть опущены при применении оператора, тогда на их место подставится `0` и/или `len(arr)`.
```golang
// содержимое main
arr := []int{6, 7, 8, 9, 10}
fmt.Println(arr[0:len(arr)])    // выведет `[6 7 8 9 10]`
fmt.Println(arr[:])             // выведет `[6 7 8 9 10]` - оба параметра опущены, идентично срезу от `0` до `len(arr)`
fmt.Println(arr[1:3])           // выведет `[7 8]`
fmt.Println(arr[:2])            // выведет `[6 7]`
fmt.Println(arr[3:])            // выведет `[9 10]`
```

### Также немного про статические массивы
Объявление статического массива (например, `var arr [10]float64`) содержит его размер, который не может изменяться впоследствии. 
При объявлении он заполняется стандартными нулевыми значениями типа (в данном случае тип - `float64`, его нулевое значение - `0.0`). 
Операции чтения и записи элементов для статического массив выполняются так же, как и для среза.
## 1. Рекурсия
При выполнении этой части ДЗ **нельзя пользоваться циклами и глобальными переменными!**
Вспомогательные функции писать можно (и иногда нужно) - решение на каждую задачу может (и скорее всего будет) состоять более, чем из одной функции. К примеру, ответ состоит из двух функций - `getMax()` и `getMaxRec()`. В функции `main()` вызывается функция `getMax()`, которая, в свою очередь, вызывает рекурсивную `getMaxRec()`.


При выполнении задач следите за всеми возможными случаями - срезы длины 0, 1; числа, равные -1, 0, 1, меньше и больше нуля и т.д.

### 1. Рекурсивный факториал
Напишите функцию `MyFact(n int) int`, возвращающую факториал числа `n`.

### 2. Наличие элемента
Напишите функцию `IsPresent(x int, arr []int) bool`, возвращающую `true` или `false` - 
в зависимости от того, есть ли элемент `x` в срезе `arr`.

### 3. Максимальный элемент
Напишите функцию `GetMax(arr []int) int`, находящую максимальный элемент среза.

### 4. Количество четных
Напишите функцию `EvenAmount(arr []int) int`, возвращающую количество четных чисел в срезе `arr`.

### 5. Срез от A до B
Напишите функцию `MyRange(start, stop, step int) []int`, возвращающую срез, содержащий целые числа в полуинтервале `[start, stop)` с шагом `step`.

### 6. Степень двойки
Напишите функцию `IsPowerOfTwo(a float64) bool`, возвращающую `true` или `false` - 
в зависимости от того, является ли `a` точной степенью двойки(числа 1.0, 2.0, 4.0 и т.д.).

### 7. Палиндром
Напишите функцию `IsSymmetric(arr []int) bool` - функция проверяет, является ли данный срез симметричным (палиндромом).

### 8. Сумма цифр
Напишите функцию `SumOfDigits(a int) int` - функция находит сумму цифр числа.

### 9. Простое?
Напишите функцию `IsPrime(a int) bool` - функция проверяет, является ли число `a` простым. 

### 10. Разворот
Напишите функцию `MyReverse(arr []int) []int` - функция возвращает развернутый срез.

### 11*. Двоичный поиск - 2 балла
Двоичный (бинарный) поиск (также известен как метод деления пополам или дихотомия) — классический алгоритм поиска элемента в отсортированном массиве (векторе), использующий дробление массива на половины. 
([Источник](https://ru.wikipedia.org/wiki/Двоичный_поиск))
В нашей его реализации мы будем проверять, есть ли данное число в массиве. Алгоритм выглядит так:<br>
Пусть мы ищем число `x = 100`. Пусть также исходный массив `arr` отсортирован по возрастанию и имеет размер `len = 64`, значит, верхняя граница поиска (макс. индекс) `high = 63`, нижняя граница поиска (мин. индекс) `low = 0`.
1. Возьмем серединный элемент диапазона поиска в массиве - элемент с индексом `(high + low) / 2` = `31`.
2. Сравним его c данным числом. Пусть `arr[31] < x`. Тогда отправляемся искать наше число в верхнюю половину диапазона.
   Теперь нижняя граница поиска `low = 31`, верхняя граница поиска `high = 63`.
3. Возьмем серединный элемент нового диапазона поиска - элемент с индексом `(high + low) / 2` = `47`.
4. Сравним его с данным числом. Пусть `arr[47] > x`. Теперь отправляемся искать наше число в нижнюю половину диапазона.
   Теперь нижняя граница поиска `low = 31`, верхняя граница поиска `high = 47`.
5. ...

Нетрудно догадаться, что через 7 подобных разделений диапазон поиска сузится до одного элемента (каждый раз он уменьшается в два раза, $\frac{64}{2^7} = 1$). 
Сравним этот элемент с данным `x` и, если они равны, то мы нашли искомый, если не нашли - его в массиве нет. 
Почему такой поиск лучше, чем обычный перебор элементов - потому что его асимптотическая сложность $O(log(n))$, что меньше чем у простого перебора ( $O(n)$ ).

Напишите функцию `BinSearch(arr *[]int, x int) bool` - функция принимает указатель на срез `arr` и целое число `x` и должна возвращать `true` или `false` в зависимости от того, есть ли элемент `x` в массиве. 
**Алгоритм поиска должен быть рекурсивным** (без использования циклов).
Обязательно проверяйте крайние случаи - на них я обязательно буду тестировать.

## 2. Указатели
В данной части функции не должны ничего возвращать, если это не указано. Циклами пользоваться разрешается. Рекурсией тоже, если не указано иное.
### 1. Сумма элементов
Напишите функцию `MySum(arr []int, sum *int)` - функция кладет сумму элементов массива по адресу `sum` (и ничего не возвращает!).

### 2. Среднее арифметическое
Напишите функцию `MyStrangeArithmeticMean(arr []*int)` - функция принимает _срез указателей на целые числа_ и кладет по всем адресам-элементам массива среднее арифметическое всех чисел по этим адресам. 
В итоге элементы среза (адреса чисел) не должны измениться, но числа по этим адресам все должны принять значение, равное их среднему арифметическому.

### 3. Пузырёк
Напишите функцию `BubbleSort(arr *[10]float64)` - функция принимает указатель на статический массив и сортирует его [методом пузырька](https://ru.wikipedia.org/wiki/Сортировка_пузырьком).

### 4*. Двоичный поиск - 2 балла
Двоичный (бинарный) поиск (также известен как метод деления пополам или дихотомия) — классический алгоритм поиска элемента в отсортированном массиве (векторе), использующий дробление массива на половины. 
([Источник](https://ru.wikipedia.org/wiki/Двоичный_поиск))
В нашей его реализации мы будем проверять, есть ли данное число в массиве. Алгоритм выглядит так:<br>
Пусть мы ищем число `x = 100`. Пусть также исходный массив `arr` отсортирован по возрастанию и имеет размер `len = 64`, значит, верхняя граница поиска (макс. индекс) `high = 63`, нижняя граница поиска (мин. индекс) `low = 0`.
1. Возьмем серединный элемент диапазона поиска в массиве - элемент с индексом `(high + low) / 2` = `31`.
2. Сравним его c данным числом. Пусть `arr[31] < x`. Тогда отправляемся искать наше число в верхнюю половину диапазона.
   Теперь нижняя граница поиска `low = 31`, верхняя граница поиска `high = 63`.
3. Возьмем серединный элемент нового диапазона поиска - элемент с индексом `(high + low) / 2` = `47`.
4. Сравним его с данным числом. Пусть `arr[47] > x`. Теперь отправляемся искать наше число в нижнюю половину диапазона.
   Теперь нижняя граница поиска `low = 31`, верхняя граница поиска `high = 47`.
5. ...

Нетрудно догадаться, что через 7 подобных разделений диапазон поиска сузится до одного элемента (каждый раз он уменьшается в два раза, $\frac{64}{2^7} = 1$). Сравним этот элемент с данным `x` и, если они равны, то мы нашли искомый, если не нашли - его в массиве нет. 
Почему такой поиск лучше, чем обычный перебор элементов - потому что его асимптотическая сложность $O(log(n))$, что меньше чем у перебора - $O(n)$.

Напишите функцию `BinSearch(arr *[]int, x int) bool` - функция принимает указатель на срез `arr` и целое число `x` и должна возвращать `true` или `false` в зависимости от того, есть ли элемент `x` в массиве. 
**Алгоритм поиска должен быть итеративным** (с использованием цикла, без рекурсии). 
Обязательно проверяйте крайние случаи - на них я обязательно буду тестировать.
