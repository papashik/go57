# Тип функции. Функции высшего порядка
## Вспоминаем
Вспомним, что такое функция.<br>
**Функция**, или **подпрограмма** — фрагмент программного кода, к которому можно обратиться из другого места программы.<br>
Что эквивалентно какой-то последовательности машинных инструкций, загруженной в оперативную память.

Если мы попытаемся просто послать имя функции на вывод, то выведется просто адрес первой инструкции этой последовательности (так называемый **адрес функции**):
```golang
package main
import "fmt"

func test() int {
	return 57
}

func main() {
	fmt.Println(test())		// выведет `57` - обычный вызов функции со скобочками после имени
	fmt.Println(test)		// выведет что-то по типу `0x100e4ab90` - адрес этой функции в оперативной памяти
	fmt.Println(main)		// выведет что-то по типу `0x104162b90` - и у функции main() есть адрес
}
```
Кроме адреса у функции есть еще **сигнатура** (например, `func hello(a, b int) (string, int)`) - та часть функции, с помощью которой компилятор идентифицирует ее среди других - а именно, это формальные параметры и возвращаемые значения функции (если компилятор не будет знать, какие параметры принимает функция, он не сможет сказать, корректно ли она была вызвана в программе).

## Тип функции. Функции в переменных
Адрес функции имеет определенный тип значения - так называемый **тип функции**. Значениями определенного типа выступают адреса функций с одинаковыми сигнатурами. Например, функции с сигнатурами `func a(one int) int` и `func b(one int) int` имеют один и тот же тип, а функция `func c(one, two int) int` имеет другой тип (она не сможет быть вызвана в том же месте, где могут быть вызваны две прошлые функции).

Запись типа функции практически идентична записи сигнатуры:
```golang
package main
import "fmt"

func one() {}						// её адрес имеет тип `func()`

func two(s string) {}				// её адрес имеет тип `func(string)`

func three() int { return 57 }		// её адрес имеет тип `func() int`

func four (a, b int) (int, int) {	// её адрес имеет тип `func(int, int) (int, int)`
	return a, b
}

func main() {
	var one_var func() = one		// тип переменной совпадает с типом функции one() - теперь в переменной one_var лежит адрес функции one()
	fmt.Println(one, one_var)		// выведет одинаковые адреса

	var three_var func() int = three
	fmt.Println(three_var())		// и теперь функцию three() можно вызвать с помощью переменной three_var! Выведет `57`
}
```
С помощью типа функции нужен можно работать с функциями как с переменными: принимать их в качестве аргументов, использовать как возвращаемые параметры и использовать функциональные литералы.

## Функциональные литералы (анонимные функции)
С литералами вы уже сталкивались - это просто конкретное значение, используещееся в коде программы. Например, числовой литерал: `5`, строковой литерал: `"привет"`, массивовый литерал: `[]int{1, 2, 3, 4, 5}`, структурный литерал: `My_struct{1, 2}` и т.д.

**Функциональный литерал**, или **анонимная функция** (ещё: лямбда-функция) - это функция, которая объявляется в месте использования и не получает уникального идентификатора (имени) для доступа к ней (до этого мы объявляли только глобальные функции, доступные из любого места программы).<br>
Функциональный литерал создаётся так:
```
// Имена параметров нужны для использования внутри тела
<тип_функции_с_именами_параметров>{ <тело_функции> }		// очень похоже на структурный литерал: <тип_структуры>{ <перечисление_значений_полей_структуры> }	
```
Отличается он от обычного объявления функции **только тем, что не имеет имени функции!** - это единственное, что нужно знать для создания литералов.

Функциональный литерал можно воспринимать как объект функции, заданный внутри другой функции. Его можно использовать при создании, можно положить в переменную или передать в другую функцию - по факту, это обычное значение переменной (которая имеет тип функции).

### Пример
```golang
var first func() = func() { fmt.Println("First") }			// теперь в переменной first лежит доступная для вызова функция
first()														// выведет `First`

var second func(int) int = func(a int) int { return a * 2} 	// лямбда-функция, возвращающая умноженное на 2 переданное число
fmt.Println(second(57))										// выведет `114`
```
Анонимные функции имеют доступ к окружению - локальным переменным той функции, в которой они объявлены. Это позволяет использовать их для создания генераторов, счетчиков с помощью статических переменных - об этом позже.

## Функции высшего порядка. Использование функций в качестве параметров других функций
Функции, тем или иным способом использующие другие функции (например, принимающие в качестве параметров или возвращающие в качестве значений), называются **функциями высшего порядка**.

### Примеры
```golang
package main
import "fmt"

func twice(a int, f func(int) int) int {		// функция высшего порядка twice() дважды применяет переданную функцию к числу и возвращает результат
	return f(f(a))
}

func mul(a int) func(int)int {					// функция высшего порядка mul() создаёт и возвращает функцию, умножающую свой аргумент на заранее заданное число
	return func(num int) int { return a * num }
}

func main() {
	fmt.Println(twice(3, func(a int) int { return a * a }))	// выведет `81` - к числу 3 два раза применяется функция возведения числа в квадрат (передаётся функциональным литералом)

	f := mul(7)				// с помощью mul() создаём функцию, умножающую переданный аргумент на 7, и кладем её в переменную f
	fmt.Println(f(5))		// выведет `35` - 7 * 5
}
```


