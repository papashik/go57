# Golang - основы 3. Функции
**Функция**, или **подпрограмма** — фрагмент программного кода, к которому можно обратиться из другого места программы.
Функция в программировании похожа на функцию в математике - она принимает какие-то аргументы и возвращает какие-то значения.
В общем случае как принимаемых аргументов, так и возвращаемых значений может не быть.

Объявление глобальной функции записывается так:
```golang
func <имя> (<формальные параметры>) <возвращаемые значения>  {
	<тело функции>
}
```
<имя> - это название функции, с помощью него можно получить к ней доступ;<br>
<формальные параметры> - список аргументов функции (и их типов);<br>
<возвращаемые значения> - список возвращаемых значений функции (и их типов);<br>
<тело функции> - программа, которая будет выполняться при вызове функции.

**Сигнатура функции** - это та часть функции, с помощью которой компилятор
идентифицирует ее среди других - а именно, это _формальные параметры и возвращаемые значения функции_.

Параметры записываются в виде `(пар1 тип1, ..., парM типM)`.
При этом, если у идущих подряд параметров совпадает тип, тип можно указать только один раз после них.

Возвращаемые значения в общем случае записываются так же, как параметры, а 
в случае единственного возвращаемого значения допустимо просто указать его тип.

### Пример: `MyFunc` - функция с пустой сигнатурой, печатающая `Hello!`:
```golang
package main

import "fmt"

func MyFunc() {
	fmt.Println("Hello!")
}

func main() {
	MyFunc() // вызов функции, напечатается `Hello!`
	MyFunc() // и еще раз напечатается `Hello!`
}
```
### Пример: `MyPrintFunc` - функция, принимающая строку и выводящая её в консоль:
```golang
package main

import "fmt"

func MyPrintFunc(parameter string) {
	fmt.Println(parameter)
}

func main() {
	a := "Pavel"
	MyPrintFunc(a) // вызов функции, напечатается `Pavel`
}
```
При вызове функции вместо **формальных параметров** (в данном случае `parameter`) 
подставляются **фактические параметры** - аргументы, передаваемые в функцию при ее вызове (в данном случае переменная `a`).

## Возврат значений
Оператор `return` (с англ. вернуть) прекращает исполнение функции и возвращает выполнение программы в точку вызова.
При этом на то место, откуда была вызвана функция, подставляются возвращаемые значения
(она возвращает их туда, откуда их попросили - на то они и возвращаемые).

Общая форма записи выглядит так: `return <возвращаемые значения>`
```golang
package main

import "fmt"

func MySummingFunc(a, b int) int {
	return a + b // возвращает сумму переданных ей аргументов
}

func main() {
	a, b := 3, 5
	fmt.Println(MySummingFunc(a, b)) // выведет `8`
}
```

### Пример - возврат нескольких значений
```golang
package main

import "fmt"

func MyCalculatingFunc(a, b int) (int, int) {
	return a + b, a * b // возвращает сумму и произведение переданных ей аргументов
}

func main() {
	a, b := 3, 5
	sum, mul := MyCalculatingFunc(a, b)
	fmt.Printf("sum = %d, mul = %d", sum, mul) // выведет `sum = 8, mul = 15`
}
```

### Пример - `return` без возврата значений
```golang
package main

import "fmt"

func MyCheckingFunc(x int, arr []int) {
	// функция проверяет, есть ли X в срезе
	for _, v := range arr {
		if v == x {
			fmt.Println(x, "найдено!")
			return // дальше искать необязательно, производим возврат
		}
	}
	fmt.Println(x, "не найдено :(") // выполнится только если Х в срезе нет
}

func main() {
	arr := []int{1, 2, 3, 4}

	MyCheckingFunc(2, arr) // выведет `2 найдено!`
	MyCheckingFunc(5, arr) // выведет `5 не найдено :(`
}
```

## Области видимости
Рассмотрим такой пример:
```golang
package main

import "fmt"

func MyTestFunc(x, y int) {
	a := x + y
	fmt.Println("Сумма равна", a)
}

func main() {
	x, y := 1, 2
	a := x * y
	b := x + y
	MyTestFunc(a, b) // выведет `Сумма равна 5`
}
```
Как мы видим, имена некоторых переменных (а также формальных и фактических параметров) совпадают в телах функций `main` и `MyTestFunc`.
Тем не менее, компилятор не выдает ошибку о повторном объявлении 
(если бы мы повторно объявили переменную в теле одной и той же функции, ошибка бы была).
Дело в том, что переменные внутри каждой функции "видит" только эта функция и функции, объявленные внутри неё.<br>
Переменные, объявленные внутри тела функции (или же являющиеся формальными параметрами) называются **локальными**.<br>
Переменные, объявленные вне тел функций называются **глобальными**.

Поэтому, если в одной глобальной функции есть локальная переменная `x`, и в другой глобальной функции есть локальная переменная `x`, то никак конфликтовать они между собой не будут.

Если рассмотреть чуть более общий случай, то в Go **область видимости** - совокупность мест в программе, откуда доступно значение той или иной переменной - открывается и закрывается фигурными скобками `{}`. Например:
```golang
package main

import "fmt"

var b int = 2 // b объявлена в глобальной области видимости - к ней можно обратиться отовсюду

func MyTestFunc(x, y int) int {
	// вместе с открытой фигурной скобкой открывается новая область видимости
	// переменные, объявленные, в этой функции, не будут видны после ее завершения
	test := x + y // к переменной test не получится обратиться извне функции 
	test += b
	return test
}

func main() {
	// здесь видна только переменная b
	b = 4 // можем ее поменять
	r := 3
	// здесь видны переменные b и r

	if r == 3 {
		a := 1
		// здесь видны переменные b, r, a
		fmt.Println(a)
	}
	// здесь переменная a уже не видна - она вышла из области видимости, видны b и r

	fmt.Println(MyTestFunc(b, r)) // выведет `11`
}
```
