# Golang - основы 4. Рекурсия, указатели, структуры
## Рекурсия
С вызовом других функций мы уже сталкивались, а что будет, если вызвать функцию внутри её самой?<br>
**Рекурсивная функция** - это функция, в записи которой содержится она сама.
Пример рекурсивной функции в математике (функция возвращает `n`-ное число Фибоначчи):<br>
$F(0) = 0$<br>
$F(1) = 1$<br>
$F(n) = F(n - 1) + F(n - 2)$<br>
Такую же функцию можно построить и в программировании:
```golang
func fib(n int) int {
	if n == 0 || n == 1 {
		return n
	}
	return fib(n - 1) + fib(n - 2)
}
```
При вызове этой рекурсивной функции каждый раз будет вызываться еще парочка, полный ход выполнения можно проследить на картинке:
![fibonacci](https://github.com/papashik/elena/assets/96551531/d5985c71-98ef-4ee6-8faf-e782d6ea9acb)
Компилятору абсолютно все равно, где находится вызываемая функция, 
как мы помним, функции - это просто инструкции процессора, размещенные в оперативной памяти последовательно.
И от того, что находится в специальном регистре - счетчике команд (_IP - Instruction Pointer_) - зависит то,
какая инструкция будет выполняться следующей. Поэтому технически рекурсивный вызов функции ничем не отличается от обычного.
### Ещё пример - рекурсивное возведение числа в степень
```golang
func power(a float64, e int) float64 {
	if e == 0 {
		return 1 // завершение рекурсии
	} else if e < 0 {
		return 1 / power(a, -e) // расчет отрицательных степеней
	}
	return a * power(a, e - 1) // основная рекурсия
}
```
## Указатели
Каждая переменная хранится в оперативной памяти компьютера. Оперативная память поделена на сегменты размером в 1 байт. Каждая переменная в ней имеет свой адрес (обычно, пишется в шестнадцатеричной СС)- например 0B5A67C. Адрес каждой переменной можно получить с помощью унарной операции `&`.
```golang
// Содержимое функции main()
a := 57
fmt.Println(&a) // выведет что-то по типу 0x4536537485, в зависимости от того, по какому адресу компилятор решит разместить эту переменную

arr := []int{1, 2, 3}
fmt.Println(&arr) // тоже выведет что-то по типу 0x453653748, адрес есть у переменной любого типа (среза, массива, числа, строки и т.д.)
fmt.Println(&arr[1]) // и у элемента среза тоже
```
Адреса (переменных) тоже можно хранить в переменных.
Переменные, хранящие адреса других переменных, называются **указателями**. Они имеют тип `*<тип оригинальной переменной>`, например указатель на целое число имеет тип `*int`, указатель на срез строк имеет тип `*[]string`, указатель на указатель на дробное число имеет тип `**float64`(да, они тоже ровно так же существуют в памяти и на них можно ссылаться).<br>
Операция чтения или записи по адресу указателя называется **разыменованием указателя**. Она записывается вот так: `*`.
```golang
// Содержимое функции main()
a := 179
b := &a // в переменной `b` хранится адрес переменной `a`
fmt.Println(b) // выведет что-то по типу 0x4536537485 - значение указателя - адрес переменной `a`

fmt.Println(*b) // разыменование указателя - чтение значения по адресу, хранящемся в переменной `b` - выведет `179`
*b = 57 // разыменование указателя - запись значения по адресу, хранящемся в переменной `b`
fmt.Println(*b) // разыменование указателя - на этот раз выведет `57`
```
