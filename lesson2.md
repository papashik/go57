# Golang - основы 2. Массивы
## Массивы
Массив - это структура данных, хранящая набор значений, идентифицируемых по индексу.
Массив последовательно занимает ячейки памяти, что позволяет быстро найти нужный элемент, зная его порядковый номер (**индекс**).
При этом нумерация начинается с нуля, то есть первый элемент будет иметь индекс 0.
При объявлении массива необходимо указать тип значений, которые будут в нем храниться (`[]int`, `[]float64`, `[]string` и т.д.).
В языке Go есть массивы, размер которых _не может_ изменяться во время выполнения программы - **статические массивы**, 
а также массивы, размер которых _может_ изменяться во время выполнения программы - **динамические массивы**.
В нашем курсе мы будем работать с динамическими массивами, которые в Go называются **срезами** (slices).
```golang
var arr []int // объявление переменной для среза, который будет хранить целые числа
fmt.Println(arr) // выведет `[]`

arr = []int{1, 2, 3, 4, 5} // инициализация пользовательскими значениями
fmt.Println(arr) // выведет `[1 2 3 4 5]`

arr = make([]int, 4) // инициализация четырьмя нулевыми значениями
fmt.Println(arr) // выведет `[0 0 0 0]`

arr[0] = 8 // присвоение значения по индексу
arr[3] = 9
fmt.Println(arr) // выведет `[8 0 0 9]`
fmt.Println(arr[3]) // выведет `9`

fmt.Println(len(arr)) // функция len() возвращает длину среза, выведет `4`
```

#### Перебор массивов
Для перебора всех элементов массива (среза) можно использовать особую форму цикла `for`:
```golang
for индекс, значение := range массив {
    // действия
}
```
Пример:
```golang
arr := []string{"Павел", "Дмитриевич", "57"} // создание среза строк

for index, value := range arr {
    // на каждой итерации цикла в переменной `index` будет лежать индекс текущего элемента,
    // а в переменной `value` значение текущего элемента
    fmt.Println(index, value) // выведет на разных строках `0 Павел`, `1 Дмитриевич`, `2 57`
}
```
Если мы не планируем использовать значения или индексы элементов, то мы можем вместо них поставить нижнее подчеркивание. 
Например, нам не нужны индексы:
```golang
arr := []float64{0.99, 0.98, 0.97, 0.55}
for _, number := range arr {
    fmt.Println(number) // выведет на разных строках `0.99`, `0.98`, `0.97`, `0.55`
}
```

Также для перебора массива можно использовать и стандартную версию цикла `for`:
```golang
var people = []string{"Grigoriy", "Dasha", "Alexander"}
for i := 0; i < len(people); i++ {
    fmt.Println(people[i]) // выведет на разных строках `Grigoriy`, `Dasha`, `Alexander`
}
```
Обратите внимание, элементы массива можно изменять, **только обращаясь к ним по индексу**.

Пусть нам нужно увеличить на единицу все элементы среза `numbers`.

**Правильный вариант:**
```golang
numbers := []int{32, 87, 33}
     
for i := range numbers {
    numbers[i]++ // обращаемся по индексу и применяем оператор инкремента (++, увеличение на 1)
}

for _, number := range numbers {
    fmt.Println(number) // выведет на разных строках `33`, `88`, `34`
}
```
**НЕПРАВИЛЬНЫЙ вариант:**
```golang
numbers := []int{32, 87, 33}
     
for _, value := range numbers {
    value++
    /* Такая запись (value++) может показаться логичной, но она не сработает,
    так как при переборе массива с помощью range в переменную value
    просто копируется значение каждого элемента массива. А через копию
    изменить оригинал, очевидно, не получится. */
}

for _, number := range numbers {
    fmt.Println(number) // выведет на разных строках `32`, `87`, `33` - элементы массива не изменятся!
}
```


#### Добавление в срез
Для добавления в срез применяется встроенная функция `append(slice, value)`. 
Первый параметр функции - срез, в который надо добавить, а второй параметр - значение, которое нужно добавить. 
Результатом функции является увеличенный срез.
```golang
numbers := []int{32, 87, 33}
numbers = append(numbers, 57)
     
for _, value := range numbers {
    fmt.Println(value) // выведет на разных строках `32`, `87`, `33`, `57`
}
```

## Примеры
### Пример - ввод N чисел в срез
```golang
var n int
fmt.Scanf("%d", &n) // ввод n

numbers := make([]int, n) // создание и инициализация среза размера n (заполняется нулями)
for i := 0; i < n; i++ {
    fmt.Scanf("%d", &numbers[i]) // считываем n чисел и кладем по адресу i-того элемента среза
}
   
for _, value := range numbers {
    fmt.Println(value) // выведет на разных строках введенные числа
}
```

### Пример - ввод N чисел в срез через append
```golang
var n, a int
var numbers []int
fmt.Scanf("%d", &n) // ввод n

for i := 0; i < n; i++ {
    fmt.Scanf("%d", &a) // так как мы не проинициализировали срез, нам нужна доп. переменная для хранения введенного числа
    numbers = append(numbers, a) // добавляем ее в срез
}
   
for _, value := range numbers {
    fmt.Println(value) // выведет на разных строках введенные числа
}
```

### Пример - задача: какие равны X?
Напишите программу, которая находит в массиве элементы, равные заданному значению `X`.
#### Входные данные
Первая строка содержит размер массива `N`. 
Во второй строке через пробел задаются `N` чисел – элементы массива. 
В третьей строке записано число `X`. 
Гарантируется, что `0 < N ≤ 10000`.
#### Выходные данные
Программа должна вывести числа – индексы элементов массива, равных `X` (нумерация с нуля).
Если таких нет - ничего не выводить.
|Входные данные|Выходные данные|
|-|-|
|`6`<br>`1 2 3 2 3 3`<br>`2`|`1`<br>`3`|
|`1`<br>`2`<br>`3`||
#### Решение
```golang
var n, x int
fmt.Scanf("%d", &n) // ввод n

numbers := make([]int, n) // создание и инициализация среза размера n (заполняется нулями)
for i := 0; i < n; i++ {
    fmt.Scanf("%d", &numbers[i]) // считываем n чисел и кладем по адресу i-того элемента среза
}

fmt.Scanf("%d", &x) // ввод x

for index, value := range numbers {
    if value == x {
        fmt.Println(index) // выводим индексы элементов, равных x
    }
}
```

## Еще немножко про циклы
### Операторы break и continue
Может возникнуть ситуация, когда нам надо при определенных условиях завершить текущую итерацию цикла, не выполнять все инструкции цикла, а сразу перейти к следующей итерации (**итерация цикла** - единоразовое выполнение кода тела цикла).
В этом случае можно использовать оператор `continue`. 

Допустим, нам нужно просуммировать положительные числа в массиве, в котором могут быть как положительные, так и отрицательные числа.
Тогда, если нам встретится отрицательное число, мы можем просто перейти к следующей итерации с помощью `continue`:
```golang
var numbers = []int{1, -2, 3, -4, 5, -6, -7, 8, -9, 10}
var sum = 0
 
for _, value := range numbers {
    if value < 0 {
        continue // переходим к следующей итерации
    }
    sum += value // sum = sum + value
}
fmt.Println("Sum:", sum) // выведет `Sum: 27` - сумма положительных чисел среза
```
Теперь пусть нам нужно проверить, есть ли данное число в массиве.
Тогда, при проходе по массиву, если мы уже нашли это число, выполнение цикла нужно прервать.
Оператор `break` полностью осуществляет выход из цикла:
```golang
var numbers = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
var num = 4 // будем искать число 4
 
for _, value := range numbers {
    if value == 4 {
        fmt.Println("Найдено!")
        break // если число равно 4, выходим из цикла, дальнейшее его выполнение бесполезно
    }
}
// ...
```
